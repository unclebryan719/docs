****

## 02 | 如何抓住重点，系统高效地学习数据结构与算法？

![在这里插入图片描述](https://img-blog.csdnimg.cn/20191217094407409.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTA2NTcwOTQ=,size_16,color_FFFFFF,t_70)

10 个数据结构：数组、链表、栈、队列、散列表、二叉树、堆、跳表、图、Trie 树；

10 个算法：递归、排序、二分查找、搜索、哈希算法、贪心算法、分治算法、回溯算法、动态规划、字符串匹配算法。


## 03 | 复杂度分析（上）：如何分析、统计算法的执行效率和资源消耗？

### 大 O 复杂度表示法

代码的执行时间 T(n) 与每行代码的执行次数 n 成正比。

![在这里插入图片描述](https://img-blog.csdnimg.cn/2019121709450237.png)


f(n) 表示每行代码执行的次数总和，公式中的 O，表示代码的执行时间 T(n) 与 f(n) 表达式成正比。

大 O 时间复杂度实际上并不具体表示代码真正的执行时间，而是表示代码执行时间随数据规模增长的变化趋势，所以，也叫作渐进时间复杂度（asymptotic time complexity），简称时间复杂度。


### 时间复杂度分析

#### 1. 只关注循环执行次数最多的一段代码

#### 2. 加法法则：总复杂度等于量级最大的那段代码的复杂度

如果 T1(n)=O(f(n))，T2(n)=O(g(n))；那么 T(n)=T1(n)+T2(n)=max(O(f(n)), O(g(n))) =O(max(f(n), g(n))).

#### 3. 乘法法则：嵌套代码的复杂度等于嵌套内外代码复杂度的乘积

如果 T1(n)=O(f(n))，T2(n)=O(g(n))；那么 T(n)=T1(n)*T2(n)=O(f(n))*O(g(n))=O(f(n)*g(n)).


### 几种常见时间复杂度实例分析

![在这里插入图片描述](https://img-blog.csdnimg.cn/2019121709455381.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTA2NTcwOTQ=,size_16,color_FFFFFF,t_70)


粗略地分为两类，多项式量级和非多项式量级。其中，非多项式量级只有两个：O(2n) 和 O(n!)。


#### 1. O(1)

一般情况下，只要算法中不存在循环语句、递归语句，即使有成千上万行的代码，其时间复杂度也是Ο(1)。


#### 2.  O(logn)、O(nlogn)

    i=1;
    while (i <= n)  {
       i = i * 3;
    }

上面 i 值的变化是：3^0  3^1  3^2 ... 3^x = n。 那么执行次数就是 x = log3 n ，时间复杂度也就是 O(log3 n)。log3 n = log3 2 * log2 n，在采用大 O 标记复杂度的时候，可以忽略系数，即 O(Cf(n)) = O(f(n))。所以，O(log2n) 就等于 O(log3n)。因此，在对数阶时间复杂度的表示方法里，我们忽略对数的“底”，统一表示为 O(logn)。

O(nlogn) 表示外面循环了 n 次。


#### 3.  O(m+n)、O(m*n)

当代码中出现 m 和 n 两个不知道的量级时，此时的时间复杂度就为 O(m+n)。


### 空间复杂度分析

时间复杂度的全称是渐进时间复杂度，表示算法的执行时间与数据规模之间的增长关系。

空间复杂度全称就是渐进空间复杂度（asymptotic space complexity），表示算法的存储空间与数据规模之间的增长关系。

常见的空间复杂度就是 O(1)、O(n)、O(n2)


### 小结

![在这里插入图片描述](https://img-blog.csdnimg.cn/20191217094701320.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTA2NTcwOTQ=,size_16,color_FFFFFF,t_70)


## 04 | 复杂度分析（下）：浅析最好、最坏、平均、均摊时间复杂度

最好情况时间复杂度（best case time complexity）、最坏情况时间复杂度（worst case time complexity）、平均情况时间复杂度（average case time complexity）、均摊时间复杂度（amortized time complexity）。


### 最好、最坏时间复杂度

最好情况时间复杂度就是，在最理想的情况下，执行这段代码的时间复杂度。

最坏情况时间复杂度就是，在最糟糕的情况下，执行这段代码的时间复杂度。


### 平均情况时间复杂度

每种情况的时间复杂度 * 发生的概率， 然后相加总和这个值就是概率论中的加权平均值，也叫作期望值，所以平均时间复杂度的全称应该叫加权平均时间复杂度或者期望时间复杂度。


### 均摊时间复杂度

通过摊还分析得到的时间复杂度叫均摊时间复杂度。

对一个数据结构进行一组连续操作中，大部分情况下时间复杂度都很低，只有个别情况下时间复杂度比较高，而且这些操作之间存在前后连贯的时序关系，这个时候，我们就可以将这一组操作放在一块儿分析，看是否能将较高时间复杂度那次操作的耗时，平摊到其他那些时间复杂度比较低的操作上。而且，在能够应用均摊时间复杂度分析的场合，一般均摊时间复杂度就等于最好情况时间复杂度。


### 05 | 数组：为什么很多编程语言中数组都从0开始编号？

#### 如何实现随机访问？

数组（Array）是一种线性表数据结构。它用一组连续的内存空间，来存储一组具有相同类型的数据。线性表就是数据排成像一条线一样的结构。

![在这里插入图片描述](https://img-blog.csdnimg.cn/20191224113426926.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTA2NTcwOTQ=,size_16,color_FFFFFF,t_70)

非线性表，比如二叉树、堆、图等。之所以叫非线性，是因为，在非线性表中，数据之间并不是简单的前后关系。

![在这里插入图片描述](https://img-blog.csdnimg.cn/20191224113456229.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTA2NTcwOTQ=,size_16,color_FFFFFF,t_70)


数组随机访问时间复杂度为 O(1)，寻址公式：

    a[i]_address = base_address + i * data_type_size


#### 低效的“插入”和“删除”

在对数组内容要求存储有序的情况下，插入元素需要移动插入位置后面的所有元素。如果数组只是简单地用来存储数据，那么插入元素时可以优化操作把插入的位置数据移到最后，再插入新数据，这样效率更高。

删除操作同样也会有大量的移动操作，在某些情况下，并不一定非得追求数组中数据的连续性。可以通过先记录下被删除的数据，然后将多次删除操作集中在一次，这样就能避免多次移动数据，提高性能。jvm 的标记清除垃圾回收算法的核心思想也是这样。


#### 警惕数组的访问越界问题

在 C 语言中，只要不是访问受限的内存，所有的内存空间都是可以自由访问的。


#### 容器能否完全替代数组？

最好在创建 ArrayList 的时候事先指定数据大小。这样能够避免数组不断地扩容，不断的申请内存和数据搬移操作。

1.Java ArrayList 无法存储基本类型，比如 int、long，需要封装为 Integer、Long 类，而 Autoboxing、Unboxing 则有一定的性能消耗，所以如果特别关注性能，或者希望使用基本类型，就可以选用数组。

2. 如果数据大小事先已知，并且对数据的操作非常简单，用不到 ArrayList 提供的大部分方法，也可以直接使用数组。

3. 还有一个是我个人的喜好，当要表示多维数组时，用数组往往会更加直观。比如 Object[][] array；而用容器的话则需要这样定义：ArrayList<ArrayList<object> > array。

业务操作可以使用容器，但更加底层的框架实现，为了性能的优化，会选择数组。


### 06 | 链表（上）：如何实现LRU缓存淘汰算法?

常见的缓存淘汰策略有三种：先进先出策略 FIFO（First In，First Out）、最少使用策略 LFU（Least Frequently Used）、最近最少使用策略 LRU（Least Recently Used）。


#### 五花八门的链表结构

数组需要的是一块连续的内存空间来存储，而链表通过“指针”将零散的内存块串联起来使用。

单向链表、循环链表、双向链表、双向循环链表

单向链表的仅插入和删除操作的时间复杂度为 O(n)，双向链表的插入和删除指定的节点操作时间复杂度为 O(1)。它们的查找某一节点操作的时间复杂度都是 O(n)。

用空间换时间的设计思想。当内存空间充足的时候，如果我们更加追求代码的执行速度，我们就可以选择空间复杂度相对较高、但时间复杂度相对很低的算法或者数据结构。相反，如果内存比较紧缺，比如代码跑在手机或者单片机上，这个时候，就要反过来用时间换空间的设计思路。


#### 链表 VS 数组性能大比拼

![在这里插入图片描述](https://img-blog.csdnimg.cn/2019122411362099.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTA2NTcwOTQ=,size_16,color_FFFFFF,t_70)

数组简单易用，在实现上使用的是连续的内存空间，可以借助 CPU 的缓存机制，预读数组中的数据，所以访问效率更高。而链表在内存中并不是连续存储，所以对 CPU 缓存不友好，没办法有效预读。


### 07 | 链表（下）：如何轻松写出正确的链表代码？

#### 技巧一：理解指针或引用的含义

将某个变量赋值给指针，实际上就是将这个变量的地址赋值给指针，或者反过来说，指针中存储了这个变量的内存地址，指向了这个变量，通过指针就能找到这个变量。


#### 技巧二：警惕指针丢失和内存泄漏


#### 技巧三：利用哨兵简化实现难度

引入哨兵结点，在任何时候，不管链表是不是空，head 指针都会一直指向这个哨兵结点。把这种有哨兵结点的链表叫带头链表。相反，没有哨兵结点的链表就叫作不带头链表。

因为引入哨兵结点，所以在插入和删除时就不需要考虑特殊情况，逻辑处理一样，简化了编程的难度。


#### 技巧四：重点留意边界条件处理

边界条件：

- 如果链表为空时，代码是否能正常工作？
- 如果链表只包含一个结点时，代码是否能正常工作？
- 如果链表只包含两个结点时，代码是否能正常工作？
- 代码逻辑在处理头结点和尾结点的时候，是否能正常工作？


#### 技巧五：举例画图，辅助思考
















































